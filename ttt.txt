
// ИНСТРУКЦИЯ
// Кроме ввода программы, пользователю потребуется также ввести некоторые числа в регистры:
// Число 65 в регистр A
// Число 78 в регистр B
// Число 55 в регистр C
// Число 0 в регистр D
// Пример ввода числа: 65 Х-П a
// Игровое поле 3х3 пронумеровано следующим образом:
// 1 2 3
// 4 5 6
// 7 8 9
// Калькулятор всегда играет за крестиков.
// При старте игры считается, что калькулятор уже сходил в центр (клетка 5), хотя он об этом не сигнализирует.
// Пользователь вводит свой первый ход (номер клетки) и нажимает С/П.
// После долгих раздумий калькулятор выдаёт свой ответный ход.
// Пользователь снова вводит свой ход и нажимает С/П и т.д.
// Если калькулятор завершает игру своей победой, последний свой ход он выдаст со знаком "минус".
// После завершения игры пользователь может сразу начать новую игру. Для этого нужно ввести свой первый ход
// (не забываем, что калькулятор уже сходил в клетку 5) и нажать С/П.

// Идея алгоритма.
// У пользователя есть 8 возможных вариантов на первом ходу, и после каждого из них есть ещё варианты развития событий.
// Дерево игры получается большим, и реализовать его "в лоб" не получится, памяти не хватит.
// Поэтому идея такая.
// Все ходы пользователя в угол одинаковы с точностью до поворота на 90*n градусов (n = 0..3) и приводят нас к одной и той
// же последовательности действий (с точностью до соответствующего поворота).
// Все ходы пользователя в неугловую клетку также одинаковы и приводят к одинаковым дальнейшим действиям с точностью
// до поворота на 90*n градусов.
// Теперь нам достаточно рассматривать не 8 вариантов, а 2 варианта, а все остальные будут реализовываться поворотами.
// Весь алгоритм заключается в следующем:
// * Поворот хода пользователя из пользовательской системы отсчета в шаблонную.
// * Сравнение "повернутого" хода пользователя с образцом.
// * Ответный ход калькулятора.
// * Поворот ответного хода калькулятора обратно из шаблонной системы отсчета в пользовательскую.
// * Выдача на экран.

// Алгоритм.
// Основная программа:
// * После первого хода пользователя нужно выяснить, ходил ли он в угловую клетку или в неугловую.
//		Для этого вращаем ход пользователя несколько раз на 90 градусов до тех пор, пока номер клетки не будет равен 1 (угол) или 2 (не угол).
// * Запоминаем, сколько раз на 90 градусов нам пришлось поворачивать (это будет "прямой" угол; на этот угол будем поворачивать и все
//		последующие ходы пользователя). Кроме того, вычисляем и запоминаем "обратный" угол (на этот угол будем поворачивать ходы калькулятора
//		перед тем, как выдавать их пользователю).
// * На протяжении остальной игры калькулятор вынуждает пользователя ходить вполне определенным образом, иначе тот сразу проиграет.
//		Введем обозначения: P и Q. Если пользователь ходил на клетку P, калькулятор будет ходить на Q и игра, как правило, продолжается;
//		иначе калькулятор ходит на P и выигрывает.
//		Для углового варианта будет такая последовательность: ходим 3; затем P=7, Q=4; затем P=6, Q=2; затем P=8, Q=9.
//		Для неуглового варианта будет такая последовательность: ходим 7; затем P=3, Q=1; затем P=9, Q=4.
// Подпрограмма поворота на 90 градусов против часовой стрелки:
//		Можно заметить, что при x < 4 результат будет 10-3x,
//		при 4 <= x < 7 результат будет 20-3x,
//		иначе результат 30-3x.
//		Поэтому алгоритм такой:
//		взять -3x;
//		прибавлять 10, пока результат не станет положительным.
// Программа всё равно не влезает в 98 байт памяти, поэтому используем лайфхак.
// Прямой переход БП и прямой вызов ПП занимают по 2 байта, а соответствующие косвенные команды занимают по 1 байту.
// Но для этого пользователю нужно внести адреса определённых подпрограмм в регистры A, B, C, D.


меткаНАЧ:
	Х-П 5
	
	4	// Выяснение типа хода (сторона/угол) и угла вращения
	Х-П 0
метка0:
	П-Х 5
	1
	K ПП A	// Вызов ПП_ВРАЩ
	Х-П 5
	1		// X == 1 ?
	-
	F x=0
	:метка1
	
	// Попали в клетку 1, т.е. это угловой вариант игры. Нужно ходить 3
	K ПП C	// Вызов ПП_СОХР_УГОЛ
	3
	П-Х 3
	К ПП A	// Вызов ПП_ВРАЩ
	4		// Дальше соперник должен ходить в 7 (иначе мы в 7 и выигрываем), а если ходил в 7, то отвечаем 4.
	Х-П 7
	7
	К ПП B	// Вызов ПП_ХОД
	2		// Затем соперник должен ходить в 6 (иначе мы в 6 и выигрываем), а если ходил в 6, то отвечаем 2.
	Х-П 7
	6
	К ПП B	// Вызов ПП_ХОД
	9		// В конце концов, соперник должен ходить в 8 (иначе мы в 8 и выигрываем), а если ходил в 8, то отвечаем 9, КОНЕЦ ИГРЫ (ничья).
	Х-П 7
	8
	К ПП B	// Вызов ПП_ХОД
	С/П		// Отобразим последний ход (он ещё не отображался)
	K БП D	// И вернемся в начало
	
метка1:
	1	// X == 2 ?
	-
	F x=0
	:метка2

	// Попали в 2, т.е. неугловой вариант игры. Нужно ходить 7
	K ПП C	// Вызов ПП_СОХР_УГОЛ
	7
	П-Х 3
	К ПП A	// Вызов ПП_ВРАЩ
	1		// Дальше соперник должен ходить в 3 (иначе мы в 3 и выигрываем), а если ходил в 3, то отвечаем 1.
	Х-П 7
	3
	К ПП B	// Вызов ПП_ХОД
	4		// Окончательно, если соперник ходил в 9, то отвечаем 4, иначе отвечаем 9 - ВЫИГРЫШ В ЛЮБОМ СЛУЧАЕ.
	Х-П 7
	9
	К ПП B	// Вызов ПП_ХОД
	F x>=0	// Тут исключение: если мы ходили 4, ПП_ХОД вернет положительный результат, но на самом деле это тоже наш выигрыш и нужно выдать отрицательное число
	:меткаДОП-1
	/-/
меткаДОП-1:
	С/П		// Отобразим последний ход (он ещё не отображался)
	K БП D	// И вернемся в начало

метка2:
	F L0	// Не совпало с шаблоном, продолжаем вращать
	:метка0

	0	// 4 раза повернули, ни с чем не совпало - это ошибка, выдадим ЕГГОГ
	Ввверх
	/

ПП_СОХР_УГОЛ:		// 5-Rg0 - "прямой" угол. 3+Rg0 = 8-результат = обратный угол (будем слишком перекручивать, но ничего страшного).
					// Вход: Rg0. Выходы: Rg2 - "прямой" угол; X и Rg3 - обратный угол
	П-Х 0
	/-/
	5
	+
	Х-П 2
	8
	<->
	-
	Х-П 3
	В/О

ПП_ВРАЩ:	// Вращать Y на 90*n градусов (n задается в X), выдать результат в X
	Х-П 1
	<->
меткаВРАЩ-0:
	3
	*
	/-/
меткаВРАЩ-1:
	1
	0
	+
	F x>=0
	:меткаВРАЩ-1
	F L1
	:меткаВРАЩ-0
	В/О

ПП_ХОД:		// Цикл одного хода.
			// Вход: Rg7 = Q, X = P, Z = предыдущий наш ход.
			// * Если наш предыдущий ход был отрицательным, игра уже была завершена и не нужно ничего делать.
			// * Иначе выведем на экран наш ход (он ещё не выводился на дисплей),
			// * Примем ввод пользователя,
			// * Повернем на "прямой" угол,
			// * Сравним с P,
			// * На основе этого примем решение - ходить P либо Q,
			// * Повернуть на обратный угол
	Х-П 6
	F .
	F .
	F x>=0		// Если X отрицательное, игра уже была завершена, ничего не делаем
	:меткаХОД-1
	С/П
	П-Х 2
	К ПП A	// Вызов ПП_ВРАЩ
	П-Х 6
	-
	F x=0
	:меткаХОД-0
	П-Х 7		// Пользователь ходил P - надо ответить Q
	П-Х 3
	К БП А		// Переход на ПП_ВРАЩ
меткаХОД-0:		// Пользователь ходил не P - надо ответить P и конец игры (вернуть наш ход со знаком "минус")
	П-Х 6
	П-Х 3
	К ПП A		// Вызов ПП_ВРАЩ
	/-/			// Возвращаем отрицательное число, чтобы было понятно, что игра уже завершена и следующих вызовах ПП_ХОД не нужно ничего делать
меткаХОД-1:
	В/О
