
// ИНСТРУКЦИЯ
// Кроме ввода программы, пользователю потребуется также ввести некоторые числа в регистры:
// Число 65 в регистр A
// Число 78 в регистр B
// Число 55 в регистр C
// Число 0 в регистр D
// Пример ввода числа: 65 Х-П a
// Игровое поле 3х3 пронумеровано следующим образом:
// 1 2 3
// 4 5 6
// 7 8 9
// Калькулятор всегда играет за крестиков.
// При старте игры считается, что калькулятор уже сходил в центр (клетка 5), хотя он об этом не сигнализирует.
// Пользователь вводит свой первый ход (номер клетки) и нажимает С/П.
// После долгих раздумий калькулятор выдаёт свой ответный ход.
// Пользователь снова вводит свой ход и нажимает С/П и т.д.
// Если калькулятор завершает игру своей победой, последний свой ход он выдаст со знаком "минус".
// После завершения игры пользователь может сразу начать новую игру. Для этого нужно ввести свой первый ход
// (не забываем, что калькулятор уже сходил в клетку 5) и нажать С/П.

// Идея алгоритма.
// У пользователя есть 8 возможных вариантов на первом ходу, и после каждого из них есть ещё варианты развития событий.
// Дерево игры получается большим, и реализовать его "в лоб" не получится, памяти не хватит.
// Поэтому идея такая.
// Все ходы пользователя в угол одинаковы с точностью до поворота на 90*n градусов (n = 0..3) и приводят нас к одной и той
// же последовательности действий (с точностью до соответствующего поворота).
// Все ходы пользователя в неугловую клетку также одинаковы и приводят к одинаковым дальнейшим действиям с точностью
// до поворота на 90*n градусов.
// Теперь нам достаточно рассматривать не 8 вариантов, а 2 варианта, а все остальные будут реализовываться поворотами.
// Весь алгоритм заключается в следующем:
// * Поворот хода пользователя из пользовательской системы отсчета в шаблонную.
// * Сравнение "повернутого" хода пользователя с образцом.
// * Ответный ход калькулятора.
// * Поворот ответного хода калькулятора обратно из шаблонной системы отсчета в пользовательскую.
// * Выдача на экран.

// Алгоритм.
// Основная программа:
// * После первого хода пользователя нужно выяснить, ходил ли он в угловую клетку или в неугловую.
//		Для этого вращаем ход пользователя несколько раз на 90 градусов до тех пор, пока номер клетки не будет равен 1 (угол) или 2 (не угол).
// * Запоминаем, сколько раз на 90 градусов нам пришлось поворачивать (это будет "прямой" угол; на этот угол будем поворачивать и все
//		последующие ходы пользователя). Кроме того, вычисляем и запоминаем "обратный" угол (на этот угол будем поворачивать ходы калькулятора
//		перед тем, как выдавать их пользователю).
// * На протяжении остальной игры калькулятор вынуждает пользователя ходить вполне определенным образом, иначе тот сразу проиграет.
//		Введем обозначения: P и Q. Если пользователь ходил на клетку P, калькулятор будет ходить на Q и игра, как правило, продолжается;
//		иначе калькулятор ходит на P и выигрывает.
//		Для углового варианта будет такая последовательность: ходим 3; затем P=7, Q=4; затем P=6, Q=2; затем P=8, Q=9.
//		Для неуглового варианта будет такая последовательность: ходим 7; затем P=3, Q=1; затем P=9, Q=4.
// Подпрограмма поворота на 90 градусов против часовой стрелки:
//		Можно заметить, что при x < 4 результат будет 10-3x,
//		при 4 <= x < 7 результат будет 20-3x,
//		иначе результат 30-3x.
//		Поэтому алгоритм такой:
//		взять -3x;
//		прибавлять 10, пока результат не станет положительным.
// Программа всё равно не влезает в 98 байт памяти, поэтому используем лайфхак.
// Прямой переход БП и прямой вызов ПП занимают по 2 байта, а соответствующие косвенные команды занимают по 1 байту.
// Но для этого пользователю нужно внести адреса определённых подпрограмм в регистры A, B, C, D.


меткаНАЧ:
00	45	Х-П 5

01	04	4	// Выяснение типа хода (сторона/угол) и угла вращения
02	40	Х-П 0
метка0:
03	65	П-Х 5
04	01	1
05	AA	K ПП A	// Вызов ПП_ВРАЩ
06	45	Х-П 5
07	01	1		// X == 1 ?
08	11	-
09	5E	F x=0
10	29	:метка1

// Попали в клетку 1, т.е. это угловой вариант игры. Нужно ходить 3
11	AC	K ПП C	// Вызов ПП_СОХР_УГОЛ
12	03	3
13	63	П-Х 3
14	AA	К ПП A	// Вызов ПП_ВРАЩ
15	04	4		// Дальше соперник должен ходить в 7 (иначе мы в 7 и выигрываем), а если ходил в 7, то отвечаем 4.
16	47	Х-П 7
17	07	7
18	AB	К ПП B	// Вызов ПП_ХОД
19	02	2		// Затем соперник должен ходить в 6 (иначе мы в 6 и выигрываем), а если ходил в 6, то отвечаем 2.
20	47	Х-П 7
21	06	6
22	AB	К ПП B	// Вызов ПП_ХОД
23	09	9		// В конце концов, соперник должен ходить в 8 (иначе мы в 8 и выигрываем), а если ходил в 8, то отвечаем 9, КОНЕЦ ИГРЫ (ничья).
24	47	Х-П 7
25	08	8
26	AB	К ПП B	// Вызов ПП_ХОД
27	50	С/П		// Отобразим последний ход (он ещё не отображался)
28	8D	K БП D	// И вернемся в начало

метка1:
29	01	1	// X == 2 ?
30	11	-
31	5E	F x=0
32	50	:метка2

// Попали в 2, т.е. неугловой вариант игры. Нужно ходить 7
33	AC	K ПП C	// Вызов ПП_СОХР_УГОЛ
34	07	7
35	63	П-Х 3
36	AA	К ПП A	// Вызов ПП_ВРАЩ
37	01	1		// Дальше соперник должен ходить в 3 (иначе мы в 3 и выигрываем), а если ходил в 3, то отвечаем 1.
38	47	Х-П 7
39	03	3
40	AB	К ПП B	// Вызов ПП_ХОД
41	04	4		// Окончательно, если соперник ходил в 9, то отвечаем 4, иначе отвечаем 9 - ВЫИГРЫШ В ЛЮБОМ СЛУЧАЕ.
42	47	Х-П 7
43	09	9
44	AB	К ПП B	// Вызов ПП_ХОД
45	59	F x>=0	// Тут исключение: если мы ходили 4, ПП_ХОД вернет положительный результат, но на самом деле это тоже наш выигрыш и нужно выдать отрицательное число
46	48	:меткаДОП-1
47	0B	/-/
меткаДОП-1:
48	50	С/П		// Отобразим последний ход (он ещё не отображался)
49	8D	K БП D	// И вернемся в начало

метка2:
50	5D	F L0	// Не совпало с шаблоном, продолжаем вращать
51	03	:метка0

52	00	0	// 4 раза повернули, ни с чем не совпало - это ошибка, выдадим ЕГГОГ
53	0E	Ввверх
54	13	/

ПП_СОХР_УГОЛ:		// 5-Rg0 - "прямой" угол. 3+Rg0 = 8-результат = обратный угол (будем слишком перекручивать, но ничего страшного).
// Вход: Rg0. Выходы: Rg2 - "прямой" угол; X и Rg3 - обратный угол
55	60	П-Х 0
56	0B	/-/
57	05	5
58	10	+
59	42	Х-П 2
60	08	8
61	14	<->
62	11	-
63	43	Х-П 3
64	52	В/О

ПП_ВРАЩ:	// Вращать Y на 90*n градусов (n задается в X), выдать результат в X
65	41	Х-П 1
66	14	<->
меткаВРАЩ-0:
67	03	3
68	12	*
69	0B	/-/
меткаВРАЩ-1:
70	01	1
71	00	0
72	10	+
73	59	F x>=0
74	70	:меткаВРАЩ-1
75	5B	F L1
76	67	:меткаВРАЩ-0
77	52	В/О

ПП_ХОД:		// Цикл одного хода.
// Вход: Rg7 = Q, X = P, Z = предыдущий наш ход.
// * Если наш предыдущий ход был отрицательным, игра уже была завершена и не нужно ничего делать.
// * Иначе выведем на экран наш ход (он ещё не выводился на дисплей),
// * Примем ввод пользователя,
// * Повернем на "прямой" угол,
// * Сравним с P,
// * На основе этого примем решение - ходить P либо Q,
// * Повернуть на обратный угол
78	46	Х-П 6
79	25	F .
80	25	F .
81	59	F x>=0		// Если X отрицательное, игра уже была завершена, ничего не делаем
82	97	:меткаХОД-1
83	50	С/П
84	62	П-Х 2
85	AA	К ПП A	// Вызов ПП_ВРАЩ
86	66	П-Х 6
87	11	-
88	5E	F x=0
89	93	:меткаХОД-0
90	67	П-Х 7		// Пользователь ходил P - надо ответить Q
91	63	П-Х 3
92	8A	К БП А		// Переход на ПП_ВРАЩ
меткаХОД-0:		// Пользователь ходил не P - надо ответить P и конец игры (вернуть наш ход со знаком "минус")
93	66	П-Х 6
94	63	П-Х 3
95	AA	К ПП A		// Вызов ПП_ВРАЩ
96	0B	/-/			// Возвращаем отрицательное число, чтобы было понятно, что игра уже завершена и следующих вызовах ПП_ХОД не нужно ничего делать
меткаХОД-1:
97	52	В/О
